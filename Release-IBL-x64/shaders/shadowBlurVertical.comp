#version 450

#include "SharedStruct.glsl"

#include "gaussianKernels.glsl"

const int LOCAL_GROUP_SIZE_Y = 128;
layout(local_size_x = 1, local_size_y = LOCAL_GROUP_SIZE_Y, local_size_z = 1) in;

layout(binding = 0) uniform ShadowBlurUniformBufferObject_T 
{
    ShadowBlurUniformBufferObject ubo;
};

layout(set = 0, binding = 1, rgba32f) uniform image2D inImage;
layout(set = 0, binding = 2, rgba32f) uniform image2D outImage;

shared vec4 sharedPixels[LOCAL_GROUP_SIZE_Y + 101];

void main()
{
    ivec2 gpos = ivec2(gl_GlobalInvocationID.xy);  // Index of central pixel being blur
    uint lposY = gl_LocalInvocationID.y;  // Local Index
    int halfWidth = int(ubo.blurWidth / 2);
    
    // Clamp horizontal to 0 - ubo.imageHeight - 1
    // gpos.y = max(0, gpos.y);
    // gpos.y = min(gpos.y, int(ubo.imageHeight - 1));
   
    // readingIndex -----------v                           v------- GPOS is dispatch pixel
    //                  ||GPOS - halfWidth| . . . . . . |GPOS| . . . . . . 77||
    //
    ivec2 readingPixel = gpos - ivec2(0, halfWidth);
    // Clamp to make it contain in the image [0, ubo.imageHeight - 1]
    readingPixel.y = max(0, readingPixel.y);
    readingPixel.y = min(readingPixel.y, int(ubo.imageHeight - 1));
    sharedPixels[lposY] = imageLoad(inImage, readingPixel);


    // on pixel Look
    //                  | -halfWidth ...........||..................GPOS..................||........... +halfWidth |

    //                  |Write readingPixel to shared memory sharedPixels       | Write Extra 100 for blur
    //                  v                                                       v
    // inImage        = ||GPOS - halfWidth|.............................77|| + ||78.............|GPOS + halfWidth)||
    //                  || -50..........................................77|| + ||78............................178||
    // -- writing          v v v v v v v v v v v v v v v v v v v v v v v v        v v v v v v v v v v v v v v v v 
    // sharedPixels   = || 0...........................................127|| + ||128...........................228||
    // Write Extra
    // only first 100 local invocation
    if(lposY < ubo.blurWidth)
    {
        ivec2 extraReadingPixel = gpos + ivec2(0, LOCAL_GROUP_SIZE_Y - halfWidth); //[78 - 178]
        // Clamp to make it contain in the image [0, ubo.imageHeight - 1]
        extraReadingPixel.y = max(0, extraReadingPixel.y );
        extraReadingPixel.y = min(extraReadingPixel.y, int(ubo.imageHeight - 1));
        // Write Extra
        sharedPixels[LOCAL_GROUP_SIZE_Y + lposY] = imageLoad(inImage, extraReadingPixel);
    }

    // Barrier for Shared Variables
    memoryBarrierShared();
    // Barrier for local thread
    barrier();

    // Blur
    // ||.........inImage...........||
    // ||-halfWidth..|....+halfWidth||
    //   \...........|............/
    //      \........|........../
    //            \..|../
    //               V
    //            outImage [gpos]
    vec4 sum = vec4(0.0);
    for(int i = -halfWidth; i <= halfWidth; ++i)
    {
        sum += gaussianKernels[i + halfWidth] * sharedPixels[lposY + i + halfWidth];
    }

    if(gpos.y >= 0 && gpos.y < int(ubo.imageHeight - 1))
    {
        imageStore(outImage, gpos, sum);
    }
}