#version 450

#include "SharedStruct.glsl"

#include "gaussianKernels.glsl"

const int LOCAL_GROUP_SIZE_Y = 128;
layout(local_size_x = 1, local_size_y = LOCAL_GROUP_SIZE_Y, local_size_z = 1) in;

layout(binding = 0) uniform AOBlurUniformBufferObject_T 
{
    AOBlurUniformBufferObject ubo;
};

layout(set = 0, binding = 1, rgba32f) uniform image2D inImage;
layout(set = 0, binding = 2, rgba32f) uniform image2D outImage;
layout(set = 0, binding = 3, rgba32f) uniform image2D normalImage;

shared vec4 sharedPixels[LOCAL_GROUP_SIZE_Y + 101];

shared vec4 sharedNormalDepths[LOCAL_GROUP_SIZE_Y + 101];

const float PI = 3.14159265358979323846;
const float e = 2.71828;

void main()
{
    ivec2 gpos = ivec2(gl_GlobalInvocationID.xy);  // Index of central pixel being blur
    uint lposY = gl_LocalInvocationID.y;  // Local Index
    int halfWidth = int(ubo.blurWidth / 2);
   
    // readingIndex -----------v                           v------- GPOS is dispatch pixel
    //                  ||GPOS - halfWidth| . . . . . . |GPOS| . . . . . . 77||
    //
    ivec2 readingPixel = gpos - ivec2(0, halfWidth);
    // Clamp to make it contain in the image [0, ubo.screenHeight - 1]
    readingPixel.y = max(0, readingPixel.y);
    readingPixel.y = min(readingPixel.y, int(ubo.screenHeight - 1));
    sharedPixels[lposY] = imageLoad(inImage, readingPixel);
    sharedNormalDepths[lposY] = imageLoad(normalImage, readingPixel);

    // on pixel Look
    //                  | -halfWidth ...........||..................GPOS..................||........... +halfWidth |

    //                  |Write readingPixel to shared memory sharedPixels       | Write Extra 100 for blur
    //                  v                                                       v
    // inImage        = ||GPOS - halfWidth|.............................77|| + ||78.............|GPOS + halfWidth)||
    //                  || -50..........................................77|| + ||78............................178||
    // -- writing          v v v v v v v v v v v v v v v v v v v v v v v v        v v v v v v v v v v v v v v v v 
    // sharedPixels   = || 0...........................................127|| + ||128...........................228||
    // Write Extra
    // only first 100 local invocation
    if(lposY < ubo.blurWidth)
    {
        ivec2 extraReadingPixel = gpos + ivec2(0, LOCAL_GROUP_SIZE_Y - halfWidth); //[78 - 178]
        // Clamp to make it contain in the image [0, ubo.screenHeight - 1]
        extraReadingPixel.y = max(0, extraReadingPixel.y );
        extraReadingPixel.y = min(extraReadingPixel.y, int(ubo.screenHeight - 1));
        // Write Extra
        sharedPixels[LOCAL_GROUP_SIZE_Y + lposY] = imageLoad(inImage, extraReadingPixel);
        sharedNormalDepths[LOCAL_GROUP_SIZE_Y + lposY] = imageLoad(normalImage, extraReadingPixel);
    }

    // Barrier for Shared Variables
    memoryBarrierShared();
    // Barrier for local thread
    barrier();


    

    float geometricWeight;

    // Blur
    // ||.........inImage...........||
    // ||-halfWidth..|....+halfWidth||
    //   \...........|............/
    //      \........|........../
    //            \..|../
    //               V
    //            outImage [gpos]
    vec4 sum = vec4(0.0);

    // Get normal and depth to check geometric weight
    vec4 normalDepth = imageLoad(normalImage, gpos);
    vec3 normal = normalDepth.rgb;
    float depth = normalDepth.a;
    
    // scale to cut off and depth
    float s = 0.1;

    for(int i = -halfWidth; i <= halfWidth; ++i)
    {
        vec3 normalAti = sharedNormalDepths[lposY + i + halfWidth].rgb;
        float depthAti = sharedNormalDepths[lposY + i + halfWidth].a;
        float depthPower = -(((depthAti - depth) * (depthAti - depth)) / (2 * s));
        float geometricWeight = (max(0.0, dot(normalAti, normal))) * (1 / sqrt(2 * PI * s) * pow(e, depthPower));

        sum += gaussianKernels[i + halfWidth] * geometricWeight * sharedPixels[lposY + i + halfWidth];
    }
    
    sum = clamp(vec4(0.0), vec4(1.0), sum);

    if(gpos.y >= 0 && gpos.y < int(ubo.screenHeight - 1))
    {
        imageStore(outImage, gpos, sum);
    }
}